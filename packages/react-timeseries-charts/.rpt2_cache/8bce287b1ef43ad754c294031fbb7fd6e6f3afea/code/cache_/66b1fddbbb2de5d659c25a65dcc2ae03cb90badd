{"code":"import * as tslib_1 from \"tslib\";\r\nimport * as _ from \"lodash\";\r\nimport { line } from \"d3-shape\";\r\nimport * as React from \"react\";\r\nimport { TimeSeries } from \"pondjs\";\r\nimport { Styler } from \"./styler\";\r\nimport { scaleAsString } from \"./util\";\r\nimport curves from \"./curve\";\r\nimport { CurveInterpolation } from \"./types\";\r\nimport { defaultLineChartChannelStyle as defaultStyle } from \"./style\";\r\nvar LineChart = (function (_super) {\r\n    tslib_1.__extends(LineChart, _super);\r\n    function LineChart() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    LineChart.prototype.shouldComponentUpdate = function (nextProps) {\r\n        var newSeries = nextProps.series;\r\n        var oldSeries = this.props.series;\r\n        var width = nextProps.width;\r\n        var timeScale = nextProps.timeScale;\r\n        var yScale = nextProps.yScale;\r\n        var interpolation = nextProps.interpolation;\r\n        var highlight = nextProps.highlight;\r\n        var selection = nextProps.selection;\r\n        var columns = nextProps.columns;\r\n        var widthChanged = this.props.width !== width;\r\n        var timeScaleChanged = scaleAsString(this.props.timeScale) !== scaleAsString(timeScale);\r\n        var yAxisScaleChanged = this.props.yScale !== yScale;\r\n        var interpolationChanged = this.props.interpolation !== interpolation;\r\n        var highlightChanged = this.props.highlight !== highlight;\r\n        var selectionChanged = this.props.selection !== selection;\r\n        var columnsChanged = this.props.columns !== columns;\r\n        var seriesChanged = false;\r\n        if (oldSeries.length !== newSeries.length) {\r\n            seriesChanged = true;\r\n        }\r\n        else {\r\n            seriesChanged = !TimeSeries.is(oldSeries, newSeries);\r\n        }\r\n        return (widthChanged ||\r\n            seriesChanged ||\r\n            timeScaleChanged ||\r\n            yAxisScaleChanged ||\r\n            interpolationChanged ||\r\n            highlightChanged ||\r\n            selectionChanged ||\r\n            columnsChanged);\r\n    };\r\n    LineChart.prototype.handleHover = function (e, column) {\r\n        if (this.props.onHighlightChange) {\r\n            this.props.onHighlightChange(column);\r\n        }\r\n    };\r\n    LineChart.prototype.handleHoverLeave = function () {\r\n        if (this.props.onHighlightChange) {\r\n            this.props.onHighlightChange(null);\r\n        }\r\n    };\r\n    LineChart.prototype.handleClick = function (e, column) {\r\n        e.stopPropagation();\r\n        if (this.props.onSelectionChange) {\r\n            this.props.onSelectionChange(column);\r\n        }\r\n    };\r\n    LineChart.prototype.providedPathStyleMap = function (column) {\r\n        if (this.props.style) {\r\n            if (this.props.style instanceof Styler) {\r\n                return this.props.style.lineChartStyle()[column];\r\n            }\r\n            else if (_.isObject(this.props.style)) {\r\n                var s = this.props.style;\r\n                return s[column];\r\n            }\r\n            else {\r\n                var fn = this.props.style;\r\n                return fn(column);\r\n            }\r\n        }\r\n    };\r\n    LineChart.prototype.pathStyle = function (column) {\r\n        var style;\r\n        var isHighlighted = this.props.highlight && column === this.props.highlight;\r\n        var isSelected = this.props.selection && column === this.props.selection;\r\n        var s = this.providedPathStyleMap(column).line;\r\n        var d = defaultStyle.line;\r\n        if (this.props.selection) {\r\n            if (isSelected) {\r\n                style = _.merge(d.selected, s.selected ? s.selected : {});\r\n            }\r\n            else if (isHighlighted) {\r\n                style = _.merge(d.highlighted, s.highlighted ? s.highlighted : {});\r\n            }\r\n            else {\r\n                style = _.merge(d.muted, s.muted ? s.muted : {});\r\n            }\r\n        }\r\n        else if (isHighlighted) {\r\n            style = _.merge(true, d.highlighted, s.highlighted ? s.highlighted : {});\r\n        }\r\n        else {\r\n            style = _.merge(true, d.normal, s.normal);\r\n        }\r\n        style.pointerEvents = \"none\";\r\n        return style;\r\n    };\r\n    LineChart.prototype.renderPath = function (data, column, key) {\r\n        var _this = this;\r\n        var hitStyle = {\r\n            stroke: \"white\",\r\n            fill: \"none\",\r\n            opacity: 0.0,\r\n            strokeWidth: 7,\r\n            cursor: \"crosshair\",\r\n            pointerEvents: \"stroke\"\r\n        };\r\n        var path = line()\r\n            .x(function (d) { return _this.props.timeScale(d.x); })\r\n            .curve(curves[this.props.interpolation])\r\n            .y(function (d) { return _this.props.yScale(d.y); })(data);\r\n        return (React.createElement(\"g\", { key: key },\r\n            React.createElement(\"path\", { d: path, style: this.pathStyle(column) }),\r\n            React.createElement(\"path\", { d: path, style: hitStyle, onClick: function (e) { return _this.handleClick(e, column); }, onMouseLeave: function () { return _this.handleHoverLeave(); }, onMouseMove: function (e) { return _this.handleHover(e, column); } })));\r\n    };\r\n    LineChart.prototype.renderLines = function () {\r\n        var _this = this;\r\n        return _.map(this.props.columns, function (column) { return _this.renderLine(column); });\r\n    };\r\n    LineChart.prototype.renderLine = function (column) {\r\n        var pathLines = [];\r\n        var count = 1;\r\n        if (this.props.breakLine) {\r\n            var currentPoints = null;\r\n            for (var _i = 0, _a = this.props.series.collection().eventList(); _i < _a.length; _i++) {\r\n                var d = _a[_i];\r\n                var timestamp = new Date(d.begin().getTime() + (d.end().getTime() - d.begin().getTime()) / 2);\r\n                var value = d.get(column);\r\n                var badPoint = _.isNull(value) || _.isNaN(value) || !_.isFinite(value);\r\n                if (!badPoint) {\r\n                    if (!currentPoints)\r\n                        currentPoints = [];\r\n                    currentPoints.push({ x: timestamp, y: value });\r\n                }\r\n                else if (currentPoints) {\r\n                    if (currentPoints.length > 1) {\r\n                        pathLines.push(this.renderPath(currentPoints, column, count));\r\n                        count += 1;\r\n                    }\r\n                    currentPoints = null;\r\n                }\r\n            }\r\n            if (currentPoints && currentPoints.length > 1) {\r\n                pathLines.push(this.renderPath(currentPoints, column, count));\r\n                count += 1;\r\n            }\r\n        }\r\n        else {\r\n            var cleanedPoints = [];\r\n            for (var _b = 0, _c = this.props.series.collection().eventList(); _b < _c.length; _b++) {\r\n                var d = _c[_b];\r\n                var timestamp = new Date(d.begin().getTime() + (d.end().getTime() - d.begin().getTime()) / 2);\r\n                var value = d.get(column);\r\n                var badPoint = _.isNull(value) || _.isNaN(value) || !_.isFinite(value);\r\n                if (!badPoint) {\r\n                    cleanedPoints.push({ x: timestamp, y: value });\r\n                }\r\n            }\r\n            pathLines.push(this.renderPath(cleanedPoints, column, count));\r\n            count += 1;\r\n        }\r\n        return React.createElement(\"g\", { key: column }, pathLines);\r\n    };\r\n    LineChart.prototype.render = function () {\r\n        return React.createElement(\"g\", null, this.renderLines());\r\n    };\r\n    LineChart.defaultProps = {\r\n        columns: [\"value\"],\r\n        interpolation: CurveInterpolation.curveLinear,\r\n        breakLine: true\r\n    };\r\n    return LineChart;\r\n}(React.Component));\r\nexport { LineChart };\r\n","map":{"mappings":""},"dts":{"name":"/Users/pmurphy/code/react-timeseries-charts/packages/react-timeseries-charts/LineChart.d.ts","text":"/// <reference types=\"react\" />\r\nimport * as React from \"react\";\r\nimport { Styler } from \"./styler\";\r\nimport { ChartProps } from \"./Charts\";\r\nimport { CurveInterpolation } from \"./types\";\r\nimport { LineChartChannelStyle, LineChartStyle } from \"./style\";\r\nexport declare type LineChartProps = ChartProps & {\r\n    series: any;\r\n    axis: string;\r\n    columns?: string[];\r\n    style?: LineChartStyle | ((column: string) => LineChartChannelStyle) | Styler;\r\n    interpolation?: CurveInterpolation;\r\n    breakLine?: boolean;\r\n    selection?: string;\r\n    onSelectionChange?: (...args: any[]) => any;\r\n    highlight?: string;\r\n    onHighlightChange?: (...args: any[]) => any;\r\n};\r\nexport declare type Point = {\r\n    x: Date;\r\n    y: number;\r\n};\r\nexport declare type PointData = Point[];\r\nexport declare class LineChart extends React.Component<LineChartProps, {}> {\r\n    static defaultProps: Partial<LineChartProps>;\r\n    shouldComponentUpdate(nextProps: LineChartProps): boolean;\r\n    handleHover(e: React.MouseEvent<SVGPathElement>, column: string): void;\r\n    handleHoverLeave(): void;\r\n    handleClick(e: React.MouseEvent<SVGPathElement>, column: string): void;\r\n    providedPathStyleMap(column: string): LineChartChannelStyle;\r\n    pathStyle(column: string): any;\r\n    renderPath(data: PointData, column: string, key: number): JSX.Element;\r\n    renderLines(): JSX.Element[];\r\n    renderLine(column: string): JSX.Element;\r\n    render(): JSX.Element;\r\n}\r\n"}}
