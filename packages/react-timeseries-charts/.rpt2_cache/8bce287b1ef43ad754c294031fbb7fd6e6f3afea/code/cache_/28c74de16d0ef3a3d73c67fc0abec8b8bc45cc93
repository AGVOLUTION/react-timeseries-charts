{"code":"import * as tslib_1 from \"tslib\";\r\nimport * as _ from \"lodash\";\r\nimport * as React from \"react\";\r\nimport { TimeRange } from \"pondjs\";\r\nimport { getElementOffset } from \"./util\";\r\nvar Brush = (function (_super) {\r\n    tslib_1.__extends(Brush, _super);\r\n    function Brush(props) {\r\n        var _this = _super.call(this, props) || this;\r\n        _this.handleBrushMouseDown = _this.handleBrushMouseDown.bind(_this);\r\n        _this.handleOverlayMouseDown = _this.handleOverlayMouseDown.bind(_this);\r\n        _this.handleHandleMouseDown = _this.handleHandleMouseDown.bind(_this);\r\n        _this.handleMouseUp = _this.handleMouseUp.bind(_this);\r\n        _this.handleClick = _this.handleClick.bind(_this);\r\n        _this.handleMouseMove = _this.handleMouseMove.bind(_this);\r\n        _this.state = {\r\n            isBrushing: false\r\n        };\r\n        return _this;\r\n    }\r\n    Brush.prototype.viewport = function () {\r\n        var _a = this.props, width = _a.width, timeScale = _a.timeScale;\r\n        var viewBeginTime = timeScale.invert(0);\r\n        var viewEndTime = timeScale.invert(width);\r\n        return new TimeRange(viewBeginTime, viewEndTime);\r\n    };\r\n    Brush.prototype.handleBrushMouseDown = function (e) {\r\n        e.preventDefault();\r\n        var x = e.pageX, y = e.pageY;\r\n        var xy0 = [Math.round(x), Math.round(y)];\r\n        var begin = +this.props.timeRange.begin();\r\n        var end = +this.props.timeRange.end();\r\n        this.setState({\r\n            isBrushing: true,\r\n            brushingInitializationSite: \"brush\",\r\n            initialBrushBeginTime: begin,\r\n            initialBrushEndTime: end,\r\n            initialBrushXYPosition: xy0\r\n        });\r\n    };\r\n    Brush.prototype.handleOverlayMouseDown = function (e) {\r\n        e.preventDefault();\r\n        var offset = getElementOffset(this.overlay);\r\n        var x = e.pageX - offset.left;\r\n        var t = this.props.timeScale.invert(x).getTime();\r\n        this.setState({\r\n            isBrushing: true,\r\n            brushingInitializationSite: \"overlay\",\r\n            initialBrushBeginTime: t,\r\n            initialBrushEndTime: t,\r\n            initialBrushXYPosition: null\r\n        });\r\n    };\r\n    Brush.prototype.handleHandleMouseDown = function (e, handle) {\r\n        e.preventDefault();\r\n        var x = e.pageX, y = e.pageY;\r\n        var xy0 = [Math.round(x), Math.round(y)];\r\n        var begin = this.props.timeRange.begin().getTime();\r\n        var end = this.props.timeRange.end().getTime();\r\n        document.addEventListener(\"mouseover\", this.handleMouseMove);\r\n        document.addEventListener(\"mouseup\", this.handleMouseUp);\r\n        this.setState({\r\n            isBrushing: true,\r\n            brushingInitializationSite: \"handle-\" + handle,\r\n            initialBrushBeginTime: begin,\r\n            initialBrushEndTime: end,\r\n            initialBrushXYPosition: xy0\r\n        });\r\n    };\r\n    Brush.prototype.handleMouseUp = function (e) {\r\n        e.preventDefault();\r\n        document.removeEventListener(\"mouseover\", this.handleMouseMove);\r\n        document.removeEventListener(\"mouseup\", this.handleMouseUp);\r\n        this.setState({\r\n            isBrushing: false,\r\n            brushingInitializationSite: null,\r\n            initialBrushBeginTime: null,\r\n            initialBrushEndTime: null,\r\n            initialBrushXYPosition: null\r\n        });\r\n    };\r\n    Brush.prototype.handleClick = function () {\r\n        if (this.props.allowSelectionClear && this.props.onTimeRangeChanged) {\r\n            this.props.onTimeRangeChanged(null);\r\n        }\r\n    };\r\n    Brush.prototype.handleMouseMove = function (e) {\r\n        e.preventDefault();\r\n        var x = e.pageX;\r\n        var y = e.pageY;\r\n        var xy = [Math.round(x), Math.round(y)];\r\n        var viewport = this.viewport();\r\n        if (this.state.isBrushing) {\r\n            var newBegin = void 0;\r\n            var newEnd = void 0;\r\n            var tb = this.state.initialBrushBeginTime;\r\n            var te = this.state.initialBrushEndTime;\r\n            if (this.state.brushingInitializationSite === \"overlay\") {\r\n                var offset = getElementOffset(this.overlay);\r\n                var xx = e.pageX - offset.left;\r\n                var t = this.props.timeScale.invert(xx).getTime();\r\n                if (t < tb) {\r\n                    newBegin = t < viewport.begin().getTime() ? +viewport.begin() : t;\r\n                    newEnd = tb > viewport.end().getTime() ? +viewport.end() : tb;\r\n                }\r\n                else {\r\n                    newBegin = tb < viewport.begin().getTime() ? +viewport.begin() : tb;\r\n                    newEnd = t > viewport.end().getTime() ? +viewport.end() : t;\r\n                }\r\n            }\r\n            else {\r\n                var xy0 = this.state.initialBrushXYPosition;\r\n                var timeOffset = this.props.timeScale.invert(xy0[0]).getTime() -\r\n                    this.props.timeScale.invert(xy[0]).getTime();\r\n                var startOffsetConstraint = timeOffset;\r\n                var endOffsetConstrain = timeOffset;\r\n                if (tb - timeOffset < +viewport.begin()) {\r\n                    startOffsetConstraint = tb - viewport.begin().getTime();\r\n                }\r\n                if (te - timeOffset > +viewport.end()) {\r\n                    endOffsetConstrain = te - viewport.end().getTime();\r\n                }\r\n                newBegin =\r\n                    this.state.brushingInitializationSite === \"brush\" ||\r\n                        this.state.brushingInitializationSite === \"handle-left\"\r\n                        ? tb - startOffsetConstraint\r\n                        : tb;\r\n                newEnd =\r\n                    this.state.brushingInitializationSite === \"brush\" ||\r\n                        this.state.brushingInitializationSite === \"handle-right\"\r\n                        ? te - endOffsetConstrain\r\n                        : te;\r\n                if (newBegin > newEnd) {\r\n                    _a = [newEnd, newBegin], newBegin = _a[0], newEnd = _a[1];\r\n                }\r\n            }\r\n            if (this.props.onTimeRangeChanged) {\r\n                this.props.onTimeRangeChanged(new TimeRange(newBegin, newEnd));\r\n            }\r\n        }\r\n        var _a;\r\n    };\r\n    Brush.prototype.renderOverlay = function () {\r\n        var _this = this;\r\n        var _a = this.props, width = _a.width, height = _a.height;\r\n        var cursor;\r\n        switch (this.state.brushingInitializationSite) {\r\n            case \"handle-right\":\r\n            case \"handle-left\":\r\n                cursor = \"ew-resize\";\r\n                break;\r\n            case \"brush\":\r\n                cursor = \"move\";\r\n                break;\r\n            default:\r\n                cursor = \"crosshair\";\r\n        }\r\n        var overlayStyle = {\r\n            fill: \"white\",\r\n            opacity: 0,\r\n            cursor: cursor\r\n        };\r\n        return (React.createElement(\"rect\", { ref: function (c) {\r\n                _this.overlay = c;\r\n            }, x: 0, y: 0, width: width, height: height, style: overlayStyle, onMouseDown: function (e) { return _this.handleOverlayMouseDown(e); }, onMouseUp: function (e) { return _this.handleMouseUp(e); }, onClick: this.handleClick }));\r\n    };\r\n    Brush.prototype.renderBrush = function () {\r\n        var _this = this;\r\n        var _a = this.props, timeRange = _a.timeRange, timeScale = _a.timeScale, height = _a.height, style = _a.style;\r\n        console.log(\"render brush props \", this.props);\r\n        console.log(this.viewport().disjoint(timeRange));\r\n        if (!timeRange) {\r\n            return React.createElement(\"g\", null);\r\n        }\r\n        var cursor;\r\n        switch (this.state.brushingInitializationSite) {\r\n            case \"handle-right\":\r\n            case \"handle-left\":\r\n                cursor = \"ew-resize\";\r\n                break;\r\n            case \"overlay\":\r\n                cursor = \"crosshair\";\r\n                break;\r\n            default:\r\n                cursor = \"move\";\r\n        }\r\n        var brushDefaultStyle = {\r\n            fill: \"#777\",\r\n            fillOpacity: 0.3,\r\n            stroke: \"#fff\",\r\n            shapeRendering: \"crispEdges\",\r\n            cursor: cursor\r\n        };\r\n        var brushStyle = _.merge(brushDefaultStyle, style);\r\n        if (!this.viewport().disjoint(timeRange)) {\r\n            var range = timeRange.intersection(this.viewport());\r\n            var begin = range.begin();\r\n            var end = range.end();\r\n            var _b = [timeScale(begin), 0], x = _b[0], y = _b[1];\r\n            var endPos = timeScale(end);\r\n            var width = endPos - x;\r\n            if (width < 1) {\r\n                width = 1;\r\n            }\r\n            var bounds = { x: x, y: y, width: width, height: height };\r\n            return (React.createElement(\"rect\", tslib_1.__assign({}, bounds, { style: brushStyle, pointerEvents: \"all\", onMouseDown: function (e) { return _this.handleBrushMouseDown(e); }, onMouseUp: function (e) { return _this.handleMouseUp(e); } })));\r\n        }\r\n        return React.createElement(\"g\", null);\r\n    };\r\n    Brush.prototype.renderHandles = function () {\r\n        var _this = this;\r\n        var _a = this.props, timeRange = _a.timeRange, timeScale = _a.timeScale, height = _a.height;\r\n        if (!timeRange) {\r\n            return React.createElement(\"g\", null);\r\n        }\r\n        var handleStyle = {\r\n            fill: \"white\",\r\n            opacity: 0,\r\n            cursor: \"ew-resize\"\r\n        };\r\n        if (!this.viewport().disjoint(timeRange)) {\r\n            var range = timeRange.intersection(this.viewport());\r\n            var begin = range.begin().getTime();\r\n            var end = range.end().getTime();\r\n            var _b = [timeScale(begin), 0], x = _b[0], y = _b[1];\r\n            var endPos = timeScale(end);\r\n            var width = endPos - x;\r\n            if (width < 1) {\r\n                width = 1;\r\n            }\r\n            var handleSize = this.props.handleSize;\r\n            var leftHandleBounds = { x: x - 1, y: y, width: handleSize, height: height };\r\n            var rightHandleBounds = {\r\n                x: x + (width - handleSize),\r\n                y: y,\r\n                width: handleSize + 1,\r\n                height: height\r\n            };\r\n            return (React.createElement(\"g\", null,\r\n                React.createElement(\"rect\", tslib_1.__assign({}, leftHandleBounds, { style: handleStyle, pointerEvents: \"all\", onMouseDown: function (e) { return _this.handleHandleMouseDown(e, \"left\"); }, onMouseUp: this.handleMouseUp })),\r\n                React.createElement(\"rect\", tslib_1.__assign({}, rightHandleBounds, { style: handleStyle, pointerEvents: \"all\", onMouseDown: function (e) { return _this.handleHandleMouseDown(e, \"right\"); }, onMouseUp: this.handleMouseUp }))));\r\n        }\r\n        return React.createElement(\"g\", null);\r\n    };\r\n    Brush.prototype.render = function () {\r\n        var _this = this;\r\n        return (React.createElement(\"g\", { onMouseMove: function (e) { return _this.handleMouseMove(e); } },\r\n            this.renderOverlay(),\r\n            this.renderBrush(),\r\n            this.renderHandles()));\r\n    };\r\n    Brush.defaultProps = {\r\n        handleSize: 6,\r\n        allowSelectionClear: false\r\n    };\r\n    return Brush;\r\n}(React.Component));\r\nexport { Brush };\r\n","map":{"mappings":""},"dts":{"name":"/Users/pmurphy/code/react-timeseries-charts/packages/react-timeseries-charts/Brush.d.ts","text":"/// <reference types=\"react\" />\r\nimport * as React from \"react\";\r\nimport { TimeRange } from \"pondjs\";\r\nimport { ChartProps } from \"./charts\";\r\nexport declare type BrushProps = ChartProps & {\r\n    style?: object;\r\n    timeRange?: TimeRange;\r\n    handleSize?: number;\r\n    allowSelectionClear?: boolean;\r\n    onTimeRangeChanged?: (d?: TimeRange) => any;\r\n};\r\nexport declare type BrushState = {\r\n    isBrushing?: boolean;\r\n    brushingInitializationSite?: string;\r\n    initialBrushBeginTime?: number;\r\n    initialBrushEndTime?: number;\r\n    initialBrushXYPosition?: number[];\r\n};\r\nexport declare class Brush extends React.Component<BrushProps, BrushState> {\r\n    static defaultProps: Partial<BrushProps>;\r\n    overlay: SVGRectElement;\r\n    constructor(props: BrushProps);\r\n    viewport(): TimeRange;\r\n    handleBrushMouseDown(e: React.MouseEvent<SVGRectElement>): void;\r\n    handleOverlayMouseDown(e: React.MouseEvent<SVGRectElement>): void;\r\n    handleHandleMouseDown(e: React.MouseEvent<SVGRectElement>, handle: string): void;\r\n    handleMouseUp(e: React.MouseEvent<SVGRectElement>): void;\r\n    handleClick(): void;\r\n    handleMouseMove(e: React.MouseEvent<SVGGElement>): void;\r\n    renderOverlay(): JSX.Element;\r\n    renderBrush(): JSX.Element;\r\n    renderHandles(): JSX.Element;\r\n    render(): JSX.Element;\r\n}\r\n"}}
