{"code":"import * as tslib_1 from \"tslib\";\r\nimport * as _ from \"lodash\";\r\nimport * as Immutable from \"immutable\";\r\nimport * as React from \"react\";\r\nimport { Event, indexedEvent, max, median, min, percentile, TimeSeries, duration, window } from \"pondjs\";\r\nimport { EventMarker } from \"./EventMarker\";\r\nimport { Styler } from \"./styler\";\r\nimport { scaleAsString } from \"./util\";\r\nimport { defaultBoxChartStyle as defaultStyle } from \"./style\";\r\nvar defaultAggregation = {\r\n    size: window(duration(\"5m\")),\r\n    reducers: {\r\n        outer: [min(), max()],\r\n        inner: [percentile(25), percentile(75)],\r\n        center: median()\r\n    }\r\n};\r\nfunction getSeries(series, column) {\r\n    return series.map(function (e) {\r\n        var v = e.get(column);\r\n        var d = {\r\n            center: null,\r\n            innerMin: null,\r\n            innerMax: null,\r\n            outerMin: null,\r\n            outerMax: null\r\n        };\r\n        switch (v.length) {\r\n            case 1:\r\n                d.center = v[0];\r\n                break;\r\n            case 2:\r\n                d.innerMin = v[0];\r\n                d.innerMax = v[1];\r\n                break;\r\n            case 3:\r\n                d.innerMin = v[0];\r\n                d.center = v[1];\r\n                d.innerMax = v[2];\r\n                break;\r\n            case 4:\r\n                d.outerMin = v[0];\r\n                d.innerMin = v[1];\r\n                d.innerMax = v[2];\r\n                d.outerMax = v[3];\r\n                break;\r\n            case 5:\r\n                d.outerMin = v[0];\r\n                d.innerMin = v[1];\r\n                d.center = v[2];\r\n                d.innerMax = v[3];\r\n                d.outerMax = v[4];\r\n                break;\r\n            default:\r\n                console.error(\"Tried to make boxchart from invalid array\");\r\n        }\r\n        return indexedEvent(e.index(), Immutable.Map(d));\r\n    });\r\n}\r\nfunction getAggregatedSeries(series, column, aggregation) {\r\n    if (aggregation === void 0) { aggregation = defaultAggregation; }\r\n    var size = aggregation.size, reducers = aggregation.reducers;\r\n    var inner = reducers.inner, outer = reducers.outer, center = reducers.center;\r\n    var d = {};\r\n    if (inner) {\r\n        d.innerMin = [column, inner[0]];\r\n        d.innerMax = [column, inner[1]];\r\n    }\r\n    if (outer) {\r\n        d.outerMin = [column, outer[0]];\r\n        d.outerMax = [column, outer[1]];\r\n    }\r\n    if (center) {\r\n        d.center = [column, center];\r\n    }\r\n    return series.fixedWindowRollup({\r\n        window: size,\r\n        aggregation: d\r\n    });\r\n}\r\nvar BoxChart = (function (_super) {\r\n    tslib_1.__extends(BoxChart, _super);\r\n    function BoxChart(props) {\r\n        var _this = _super.call(this, props) || this;\r\n        _this.series = null;\r\n        if (props.series.size() > 0) {\r\n            if (props.series.atFirst().keyType() === \"time\") {\r\n                var input = props.series;\r\n                _this.series = getAggregatedSeries(input, props.column, props.aggregation);\r\n            }\r\n            else {\r\n                var input = props.series;\r\n                _this.series = getSeries(input, props.column);\r\n            }\r\n        }\r\n        return _this;\r\n    }\r\n    BoxChart.prototype.componentWillReceiveProps = function (nextProps) {\r\n        var aggregation = nextProps.aggregation;\r\n        var aggregationChanged = false;\r\n        if (_.isUndefined(aggregation) !== _.isUndefined(this.props.aggregation)) {\r\n            aggregationChanged = true;\r\n        }\r\n        if (aggregation && this.props.aggregation) {\r\n            if (aggregation.size !== this.props.aggregation.size) {\r\n                aggregationChanged = true;\r\n            }\r\n        }\r\n        if (aggregationChanged) {\r\n            this.series = getAggregatedSeries(nextProps.series, nextProps.column, nextProps.aggregation);\r\n        }\r\n    };\r\n    BoxChart.prototype.shouldComponentUpdate = function (nextProps) {\r\n        var newSeries = nextProps.series;\r\n        var oldSeries = this.props.series;\r\n        var width = nextProps.width;\r\n        var timeScale = nextProps.timeScale;\r\n        var yScale = nextProps.yScale;\r\n        var column = nextProps.column;\r\n        var style = nextProps.style;\r\n        var aggregation = nextProps.aggregation;\r\n        var highlighted = nextProps.highlighted;\r\n        var selected = nextProps.selected;\r\n        var widthChanged = this.props.width !== width;\r\n        var timeScaleChanged = scaleAsString(this.props.timeScale) !== scaleAsString(timeScale);\r\n        var yAxisScaleChanged = this.props.yScale !== yScale;\r\n        var columnChanged = this.props.column !== column;\r\n        var styleChanged = JSON.stringify(this.props.style) !== JSON.stringify(style);\r\n        var highlightedChanged = this.props.highlighted !== highlighted;\r\n        var selectedChanged = this.props.selected !== selected;\r\n        var aggregationChanged = false;\r\n        if (_.isUndefined(aggregation) !== _.isUndefined(this.props.aggregation)) {\r\n            aggregationChanged = true;\r\n        }\r\n        if (aggregation && this.props.aggregation) {\r\n            if (aggregation.size !== this.props.aggregation.size) {\r\n                aggregationChanged = true;\r\n            }\r\n        }\r\n        var seriesChanged = false;\r\n        if (oldSeries.size() !== newSeries.size()) {\r\n            seriesChanged = true;\r\n        }\r\n        else {\r\n            seriesChanged = !TimeSeries.is(oldSeries, newSeries);\r\n        }\r\n        if (seriesChanged) {\r\n            if (nextProps.series.size() > 0) {\r\n                if (nextProps.series.atFirst().keyType() === \"time\") {\r\n                    var input = nextProps.series;\r\n                    this.series = getAggregatedSeries(input, nextProps.column, nextProps.aggregation);\r\n                }\r\n                else {\r\n                    var input = nextProps.series;\r\n                    this.series = getSeries(nextProps.series, nextProps.column);\r\n                }\r\n            }\r\n        }\r\n        return (seriesChanged ||\r\n            timeScaleChanged ||\r\n            widthChanged ||\r\n            columnChanged ||\r\n            styleChanged ||\r\n            yAxisScaleChanged ||\r\n            aggregationChanged ||\r\n            highlightedChanged ||\r\n            selectedChanged);\r\n    };\r\n    BoxChart.prototype.handleHover = function (e, event) {\r\n        if (this.props.onHighlightChange) {\r\n            this.props.onHighlightChange(event);\r\n        }\r\n    };\r\n    BoxChart.prototype.handleHoverLeave = function () {\r\n        if (this.props.onHighlightChange) {\r\n            this.props.onHighlightChange(null);\r\n        }\r\n    };\r\n    BoxChart.prototype.handleClick = function (e, event) {\r\n        if (this.props.onSelectionChange) {\r\n            this.props.onSelectionChange(event);\r\n        }\r\n        e.stopPropagation();\r\n    };\r\n    BoxChart.prototype.providedStyleArray = function (column) {\r\n        var levelStyles = defaultStyle;\r\n        if (this.props.style) {\r\n            if (this.props.style instanceof Styler) {\r\n                levelStyles = this.props.style.boxChartStyle()[column];\r\n            }\r\n            else if (_.isFunction(this.props.style)) {\r\n                levelStyles = this.props.style(column);\r\n            }\r\n            else if (_.isObject(this.props.style)) {\r\n                levelStyles = this.props.style[column];\r\n            }\r\n        }\r\n        return levelStyles;\r\n    };\r\n    BoxChart.prototype.style = function (column, event, level) {\r\n        var style;\r\n        if (!this.providedStyle) {\r\n            this.providedStyle = this.providedStyleArray(this.props.column);\r\n        }\r\n        if (!_.isNull(this.providedStyle) &&\r\n            (!_.isArray(this.providedStyle) || this.providedStyle.length !== 3)) {\r\n            console.warn(\"Provided style to BoxChart should be an array of 3 objects\");\r\n            return defaultStyle[level];\r\n        }\r\n        var isHighlighted = this.props.highlighted && Event.is(this.props.highlighted, event);\r\n        var isSelected = this.props.selected && Event.is(this.props.selected, event);\r\n        if (this.props.selected) {\r\n            if (isSelected) {\r\n                if (!this.selectedStyle || !this.selectedStyle[level]) {\r\n                    if (!this.selectedStyle) {\r\n                        this.selectedStyle = [];\r\n                    }\r\n                    this.selectedStyle[level] = _.merge(defaultStyle[level].selected, this.providedStyle[level].selected ? this.providedStyle[level].selected : {});\r\n                }\r\n                style = this.selectedStyle[level];\r\n            }\r\n            else if (isHighlighted) {\r\n                if (!this.highlightedStyle || !this.highlightedStyle[level]) {\r\n                    if (!this.highlightedStyle) {\r\n                        this.highlightedStyle = [];\r\n                    }\r\n                    this.highlightedStyle[level] = _.merge(defaultStyle[level].highlighted, this.providedStyle[level].highlighted\r\n                        ? this.providedStyle[level].highlighted\r\n                        : {});\r\n                }\r\n                style = this.highlightedStyle[level];\r\n            }\r\n            else {\r\n                if (!this.mutedStyle) {\r\n                    this.mutedStyle = [];\r\n                }\r\n                if (!this.mutedStyle[level]) {\r\n                    this.mutedStyle[level] = _.merge(defaultStyle[level].muted, this.providedStyle[level].muted ? this.providedStyle[level].muted : {});\r\n                }\r\n                style = this.mutedStyle[level];\r\n            }\r\n        }\r\n        else if (isHighlighted) {\r\n            style = _.merge(defaultStyle[level].highlighted, this.providedStyle[level].highlighted ? this.providedStyle[level].highlighted : {});\r\n        }\r\n        else {\r\n            if (!this.normalStyle) {\r\n                this.normalStyle = [];\r\n            }\r\n            if (!this.normalStyle[level]) {\r\n                this.normalStyle[level] = _.merge(defaultStyle[level].normal, this.providedStyle[level].normal ? this.providedStyle[level].normal : {});\r\n            }\r\n            style = this.normalStyle[level];\r\n        }\r\n        return style;\r\n    };\r\n    BoxChart.prototype.renderBars = function () {\r\n        var _this = this;\r\n        var _a = this.props, timeScale = _a.timeScale, yScale = _a.yScale, column = _a.column;\r\n        var innerSpacing = +this.props.innerSpacing;\r\n        var outerSpacing = +this.props.outerSpacing;\r\n        var innerSize = +this.props.innerSize;\r\n        var outerSize = +this.props.outerSize;\r\n        var bars = [];\r\n        var eventMarker;\r\n        var events = this.series.collection().eventList();\r\n        events.forEach(function (event) {\r\n            var index = event.index();\r\n            var begin = event.begin();\r\n            var end = event.end();\r\n            var d = event.getData();\r\n            var beginPosInner = timeScale(begin) + innerSpacing;\r\n            var endPosInner = timeScale(end) - innerSpacing;\r\n            var beginPosOuter = timeScale(begin) + outerSpacing;\r\n            var endPosOuter = timeScale(end) - outerSpacing;\r\n            var innerWidth = innerSize || endPosInner - beginPosInner;\r\n            if (innerWidth < 1) {\r\n                innerWidth = 1;\r\n            }\r\n            var outerWidth = outerSize || endPosOuter - beginPosOuter;\r\n            if (outerWidth < 1) {\r\n                outerWidth = 1;\r\n            }\r\n            var c = timeScale(begin) + (timeScale(end) - timeScale(begin)) / 2;\r\n            var xInner = timeScale(begin) + innerSpacing;\r\n            if (innerSize) {\r\n                xInner = c - innerSize / 2;\r\n            }\r\n            var xOuter = timeScale(begin) + outerSpacing;\r\n            if (outerSize) {\r\n                xOuter = c - outerSize / 2;\r\n            }\r\n            var styles = [];\r\n            styles[0] = _this.style(column, event, 0);\r\n            styles[1] = _this.style(column, event, 1);\r\n            styles[2] = _this.style(column, event, 2);\r\n            var innerMin = d.has(\"innerMin\") ? yScale(event.get(\"innerMin\")) : null;\r\n            var innerMax = d.has(\"innerMax\") ? yScale(event.get(\"innerMax\")) : null;\r\n            var outerMin = d.has(\"outerMin\") ? yScale(event.get(\"outerMin\")) : null;\r\n            var outerMax = d.has(\"outerMax\") ? yScale(event.get(\"outerMax\")) : null;\r\n            var center = d.has(\"center\") ? yScale(event.get(\"center\")) : null;\r\n            var hasInner = true;\r\n            var hasOuter = true;\r\n            var hasCenter = true;\r\n            if (_.isNull(innerMin) || _.isNull(innerMax)) {\r\n                hasInner = false;\r\n            }\r\n            if (_.isNull(outerMin) || _.isNull(outerMax)) {\r\n                hasOuter = false;\r\n            }\r\n            if (_.isNull(center)) {\r\n                hasCenter = false;\r\n            }\r\n            var ymax = null;\r\n            if (hasOuter) {\r\n                var level = 0;\r\n                if (!hasInner) {\r\n                    level += 1;\r\n                }\r\n                if (!hasCenter) {\r\n                    level += 1;\r\n                }\r\n                var keyOuter = _this.series.name() + \"-\" + index + \"-outer\";\r\n                var boxOuter = {\r\n                    x: xOuter,\r\n                    y: outerMax,\r\n                    width: outerWidth,\r\n                    height: outerMin - outerMax,\r\n                    rx: 2,\r\n                    ry: 2\r\n                };\r\n                var barOuterProps = tslib_1.__assign({ key: keyOuter, style: styles[level] }, boxOuter);\r\n                if (_this.props.onSelectionChange) {\r\n                    barOuterProps.onClick = function (e) {\r\n                        return _this.handleClick(e, event);\r\n                    };\r\n                }\r\n                if (_this.props.onHighlightChange) {\r\n                    barOuterProps.onMouseMove = function (e) {\r\n                        return _this.handleHover(e, event);\r\n                    };\r\n                    barOuterProps.onMouseLeave = function () { return _this.handleHoverLeave(); };\r\n                }\r\n                bars.push(React.createElement(\"rect\", tslib_1.__assign({}, barOuterProps)));\r\n                ymax = \"outerMax\";\r\n            }\r\n            if (hasInner) {\r\n                var level = 1;\r\n                if (!hasCenter) {\r\n                    level += 1;\r\n                }\r\n                var keyInner = _this.series.name() + \"-\" + index + \"-inner\";\r\n                var boxInner = {\r\n                    x: xInner,\r\n                    y: innerMax,\r\n                    width: innerWidth,\r\n                    height: innerMin - innerMax,\r\n                    rx: 1,\r\n                    ry: 1\r\n                };\r\n                var barInnerProps = tslib_1.__assign({ key: keyInner }, boxInner, { style: styles[level] });\r\n                if (_this.props.onSelectionChange) {\r\n                    barInnerProps.onClick = function (e) {\r\n                        return _this.handleClick(e, event);\r\n                    };\r\n                }\r\n                if (_this.props.onHighlightChange) {\r\n                    barInnerProps.onMouseMove = function (e) {\r\n                        return _this.handleHover(e, event);\r\n                    };\r\n                    barInnerProps.onMouseLeave = function () { return _this.handleHoverLeave(); };\r\n                }\r\n                bars.push(React.createElement(\"rect\", tslib_1.__assign({}, barInnerProps)));\r\n                ymax = ymax || \"innerMax\";\r\n            }\r\n            if (hasCenter) {\r\n                var level = 2;\r\n                var keyCenter = _this.series.name() + \"-\" + index + \"-center\";\r\n                var boxCenter = {\r\n                    x: xInner,\r\n                    y: center,\r\n                    width: innerWidth,\r\n                    height: 1\r\n                };\r\n                var barCenterProps = tslib_1.__assign({ key: keyCenter }, boxCenter, { style: styles[level] });\r\n                if (_this.props.onSelectionChange) {\r\n                    barCenterProps.onClick = function (e) {\r\n                        return _this.handleClick(e, event);\r\n                    };\r\n                }\r\n                if (_this.props.onHighlightChange) {\r\n                    barCenterProps.onMouseMove = function (e) {\r\n                        return _this.handleHover(e, event);\r\n                    };\r\n                    barCenterProps.onMouseLeave = function () { return _this.handleHoverLeave(); };\r\n                }\r\n                bars.push(React.createElement(\"rect\", tslib_1.__assign({}, barCenterProps)));\r\n                ymax = ymax || \"center\";\r\n            }\r\n            var isHighlighted = _this.props.highlighted && Event.is(_this.props.highlighted, event);\r\n            if (isHighlighted && _this.props.info) {\r\n                var eventMarkerProps = {\r\n                    key: \"marker-\" + index,\r\n                    event: event,\r\n                    column: column,\r\n                    type: \"point\",\r\n                    info: _this.props.info,\r\n                    style: _this.props.infoStyle,\r\n                    yValueFunc: function (e) { return e.get(ymax); },\r\n                    width: _this.props.width,\r\n                    height: _this.props.height,\r\n                    infoWidth: _this.props.infoWidth,\r\n                    infoHeight: _this.props.infoWidth,\r\n                    infoTimeFormat: _this.props.infoTimeFormat,\r\n                    markerRadius: _this.props.infoMarkerRadius\r\n                };\r\n                eventMarker = React.createElement(EventMarker, tslib_1.__assign({}, eventMarkerProps));\r\n            }\r\n        });\r\n        return (React.createElement(\"g\", null,\r\n            bars,\r\n            eventMarker));\r\n    };\r\n    BoxChart.prototype.render = function () {\r\n        return React.createElement(\"g\", null, this.renderBars());\r\n    };\r\n    BoxChart.defaultProps = {\r\n        column: \"value\",\r\n        innerSpacing: 1.0,\r\n        outerSpacing: 2.0,\r\n        infoStyle: {\r\n            stroke: \"#999\",\r\n            fill: \"white\",\r\n            opacity: 0.9,\r\n            pointerEvents: \"none\"\r\n        },\r\n        stemStyle: {\r\n            stroke: \"#999\",\r\n            cursor: \"crosshair\",\r\n            pointerEvents: \"none\"\r\n        },\r\n        markerStyle: {\r\n            fill: \"#999\"\r\n        },\r\n        infoMarkerRadius: 2,\r\n        infoWidth: 90,\r\n        infoHeight: 30\r\n    };\r\n    return BoxChart;\r\n}(React.Component));\r\nexport { BoxChart };\r\n","map":{"mappings":""},"dts":{"name":"/Users/pmurphy/code/react-timeseries-charts/packages/react-timeseries-charts/BoxChart.d.ts","text":"/// <reference types=\"react\" />\r\nimport * as React from \"react\";\r\nimport { Event, Index, Time, TimeSeries, Window } from \"pondjs\";\r\nimport { ChartProps } from \"./Charts\";\r\nimport { LabelValueList } from \"./types\";\r\nimport { Styler } from \"./styler\";\r\nimport { BoxChartStyle, BoxChartChannelStyle as ChannelStyle, LevelStyle, EventMarkerStyle } from \"./style\";\r\nimport { ReducerFunction } from \"pondjs/lib/types\";\r\nimport { CSSProperties } from \"react\";\r\nexport declare type AggregationSpec = {\r\n    size: Window;\r\n    reducers: {\r\n        outer?: [ReducerFunction, ReducerFunction];\r\n        inner?: [ReducerFunction, ReducerFunction];\r\n        center?: ReducerFunction;\r\n    };\r\n};\r\nexport declare type BoxChartRanges = {\r\n    center: number;\r\n    innerMin: number;\r\n    innerMax: number;\r\n    outerMin: number;\r\n    outerMax: number;\r\n};\r\nexport declare type BoxChartProps = ChartProps & {\r\n    series?: TimeSeries<Index> | TimeSeries<Time>;\r\n    column?: string;\r\n    aggregation?: AggregationSpec;\r\n    style?: BoxChartStyle | ((channel: string) => ChannelStyle) | Styler;\r\n    info?: LabelValueList | string;\r\n    infoStyle?: EventMarkerStyle;\r\n    infoTimeFormat?: ((date: Date) => string) | string;\r\n    infoWidth?: number;\r\n    infoHeight?: number;\r\n    infoMarkerRadius?: number;\r\n    innerSpacing?: number;\r\n    outerSpacing?: number;\r\n    innerSize?: number;\r\n    outerSize?: number;\r\n    selected?: Event<Index>;\r\n    highlighted?: Event<Index>;\r\n    onSelectionChange?: (e: Event<Index>) => any;\r\n    onHighlightChange?: (e: Event<Index>) => any;\r\n};\r\nexport declare class BoxChart extends React.Component<BoxChartProps> {\r\n    static defaultProps: {\r\n        column: string;\r\n        innerSpacing: number;\r\n        outerSpacing: number;\r\n        infoStyle: {\r\n            stroke: string;\r\n            fill: string;\r\n            opacity: number;\r\n            pointerEvents: string;\r\n        };\r\n        stemStyle: {\r\n            stroke: string;\r\n            cursor: string;\r\n            pointerEvents: string;\r\n        };\r\n        markerStyle: {\r\n            fill: string;\r\n        };\r\n        infoMarkerRadius: number;\r\n        infoWidth: number;\r\n        infoHeight: number;\r\n    };\r\n    series: TimeSeries<Index>;\r\n    providedStyle: CSSProperties;\r\n    selectedStyle: CSSProperties;\r\n    highlightedStyle: CSSProperties;\r\n    mutedStyle: CSSProperties;\r\n    normalStyle: CSSProperties;\r\n    constructor(props: BoxChartProps);\r\n    componentWillReceiveProps(nextProps: BoxChartProps): void;\r\n    shouldComponentUpdate(nextProps: BoxChartProps): boolean;\r\n    handleHover(e: React.MouseEvent<SVGElement>, event: Event<Index>): void;\r\n    handleHoverLeave(): void;\r\n    handleClick(e: React.MouseEvent<SVGElement>, event: Event<Index>): void;\r\n    providedStyleArray(column: string): LevelStyle[];\r\n    style(column: string, event: Event<Index>, level: number): LevelStyle;\r\n    renderBars(): JSX.Element;\r\n    render(): JSX.Element;\r\n}\r\n"}}
